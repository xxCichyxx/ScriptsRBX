-- Funkcja do uzyskania specyficznych części samochodu
local function getSpecificParts(car)
    local parts = {}
    local function addPartsFromFolder(folder)
        if folder and folder:IsA("Folder") then
            for _, child in pairs(folder:GetChildren()) do
                if child:IsA("BasePart") then
                    table.insert(parts, child)
                end
            end
        end
    end
    local hitbox = car:FindFirstChild("Hitbox")
    local wheels = car:FindFirstChild("Wheels")
    local main = car:FindFirstChild("Main")
    if hitbox then addPartsFromFolder(hitbox) end
    if wheels then addPartsFromFolder(wheels) end
    if main and main:IsA("BasePart") then table.insert(parts, main) end
    return parts
end

-- Funkcja do obracania i "skakania" części samochodu
local function spinAndJumpCarPart(object)
    if object:IsA("BasePart") then
        local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
        bodyAngularVelocity.MaxTorque = Vector3.new(10000, 10000, 10000)
        bodyAngularVelocity.AngularVelocity = Vector3.new(0, 100, 0)
        bodyAngularVelocity.P = 5000
        bodyAngularVelocity.Parent = object

        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
        bodyVelocity.Velocity = Vector3.new(0, 200, 0)
        bodyVelocity.Parent = object

        task.spawn(function()
            local originalPosition = object.Position
            while true do
                object.CFrame = CFrame.new(originalPosition + Vector3.new(0, math.sin(tick() * 10) * 0.5, 0))
                task.wait(0.03)
            end
        end)
    else
        warn(object.Name .. " nie jest typu BasePart i został pominięty.")
    end
end

-- Flagi do monitorowania
local monitoringActive = false
local connections = {}

-- Funkcja do rozpoczęcia monitorowania samochodów
local function startMonitoring()
    if monitoringActive then
        warn("Monitoring jest już aktywny!")
        return
    end

    monitoringActive = true
    for _, car in pairs(workspace.Cars:GetChildren()) do
        if not car:GetAttribute("AutofarmActivated") then
            car:SetAttribute("AutofarmActivated", false)
        end
        local seats = car:FindFirstChild("Seats")
        if seats then
            local driverSeat = seats:FindFirstChild("Driver")
            if driverSeat then
                local connection = driverSeat:GetPropertyChangedSignal("Occupant"):Connect(function()
                    if not monitoringActive then return end
                    local occupant = driverSeat.Occupant
                    if occupant then
                        local player = game.Players:GetPlayerFromCharacter(occupant.Parent)
                        if player and player == game.Players.LocalPlayer then
                            if not car:GetAttribute("AutofarmActivated") then
                                local parts = getSpecificParts(car)
                                for _, part in pairs(parts) do
                                    spinAndJumpCarPart(part)
                                end
                                car:SetAttribute("AutofarmActivated", true)
                                driverSeat:GetPropertyChangedSignal("Occupant"):Wait()
                                if not driverSeat.Occupant then
                                    car:SetAttribute("AutofarmActivated", false)
                                end
                            end
                        end
                    end
                end)
                table.insert(connections, connection)
            end
        end
    end
end

-- Funkcja do zatrzymania monitorowania samochodów
local function stopMonitoring()
    if not monitoringActive then
        warn("Monitoring nie jest aktywny!")
        return
    end

    monitoringActive = false
    for _, connection in pairs(connections) do
        connection:Disconnect()
    end
    connections = {}
end

-- Zwrócenie funkcji do obsługi toggle
return {
    startMonitoring = startMonitoring,
    stopMonitoring = stopMonitoring
}

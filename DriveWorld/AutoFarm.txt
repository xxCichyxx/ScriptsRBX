-- Funkcja do uzyskania specyficznych części samochodu
local function getSpecificParts(car)
    local parts = {}
    local function addPartsFromFolder(folder)
        if folder and folder:IsA("Folder") then
            for _, child in pairs(folder:GetChildren()) do
                if child:IsA("BasePart") then
                    table.insert(parts, child)
                end
            end
        end
    end
    local hitbox = car:FindFirstChild("Hitbox")
    local wheels = car:FindFirstChild("Wheels")
    local main = car:FindFirstChild("Main")
    if hitbox then addPartsFromFolder(hitbox) end
    if wheels then addPartsFromFolder(wheels) end
    if main and main:IsA("BasePart") then table.insert(parts, main) end
    return parts
end

-- Funkcja obracania i skakania części
local function spinAndJumpCarPart(part, active)
    if active then
        local originalCFrame = part.CFrame
        part:SetAttribute("SpinJumpOriginalCFrame", originalCFrame)
        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(0, 100000, 0)
        bodyVelocity.Velocity = Vector3.new(0, 5, 0) -- Płynny ruch w górę
        bodyVelocity.Parent = part

        task.spawn(function()
            while part:GetAttribute("SpinJumpActive") do
                bodyVelocity.Velocity = Vector3.new(0, math.sin(tick() * 5) * 5, 0) -- Ruch sinusoidalny
                task.wait(0.03)
            end
            -- Przywracanie oryginalnej pozycji
            bodyVelocity:Destroy()
            part.CFrame = originalCFrame
        end)
    else
        part:SetAttribute("SpinJumpActive", false)
    end
end

-- Funkcja autofarm
local function startAutofarm(parts, active)
    local maxHeight = 380
    local minHeight = 180
    local fallVelocity = -10
    local delayBetweenMoves = 0.05

    local function teleportPart(part)
        if not part:IsDescendantOf(workspace) then return end
        if active then
            part.CFrame = CFrame.new(part.Position.X, maxHeight, part.Position.Z)
            while part.Position.Y > minHeight and active do
                part.CFrame = CFrame.new(part.Position.X, part.Position.Y + fallVelocity, part.Position.Z)
                task.wait(delayBetweenMoves)
            end
            part.CFrame = CFrame.new(part.Position.X, maxHeight, part.Position.Z)
        else
            part.CFrame = part:GetAttribute("AutofarmOriginalCFrame") or part.CFrame
        end
    end

    for _, part in pairs(parts) do
        if active then
            part:SetAttribute("AutofarmOriginalCFrame", part.CFrame)
            coroutine.wrap(function()
                while active do
                    teleportPart(part)
                    task.wait(delayBetweenMoves)
                end
            end)()
        else
            teleportPart(part)
        end
    end
end

-- Zarządzanie monitorowaniem obracania/skakania
local spinJumpMonitoringActive = false
local function startSpinJumpMonitoring()
    if spinJumpMonitoringActive then
        warn("SpinJump monitoring już działa!")
        return
    end

    local carsFolder = workspace:FindFirstChild("Cars")
    if not carsFolder then
        warn("Folder 'Cars' nie istnieje w workspace!")
        return
    end

    spinJumpMonitoringActive = true

    for _, car in pairs(carsFolder:GetChildren()) do
        if not car:GetAttribute("SpinJumpActivated") then
            car:SetAttribute("SpinJumpActivated", false)
        end

        local parts = getSpecificParts(car)
        local driverSeat = car:FindFirstChild("Seats") and car.Seats:FindFirstChild("Driver")

        if driverSeat and driverSeat.Occupant then
            for _, part in pairs(parts) do
                part:SetAttribute("SpinJumpActive", true)
                spinAndJumpCarPart(part, true)
            end
            car:SetAttribute("SpinJumpActivated", true)
        end
    end
end

local function stopSpinJumpMonitoring()
    spinJumpMonitoringActive = false

    local carsFolder = workspace:FindFirstChild("Cars")
    if carsFolder then
        for _, car in pairs(carsFolder:GetChildren()) do
            if car:GetAttribute("SpinJumpActivated") then
                local parts = getSpecificParts(car)
                for _, part in pairs(parts) do
                    part:SetAttribute("SpinJumpActive", false)
                end
                car:SetAttribute("SpinJumpActivated", false)
            end
        end
    end
end

-- Zarządzanie monitorowaniem autofarm
local autofarmMonitoringActive = false

local function startAutofarmMonitoring()
    if autofarmMonitoringActive then
        warn("Autofarm monitoring jest już aktywny!")
        return
    end

    autofarmMonitoringActive = true

    for _, car in pairs(workspace.Cars:GetChildren()) do
        if not car:GetAttribute("AutofarmActivated") then
            car:SetAttribute("AutofarmActivated", false)
        end

        local parts = getSpecificParts(car)
        local driverSeat = car:FindFirstChild("Seats") and car.Seats:FindFirstChild("Driver")

        if driverSeat and driverSeat.Occupant then
            startAutofarm(parts, true)
            car:SetAttribute("AutofarmActivated", true)
        end
    end
end

local function stopAutofarmMonitoring()
    autofarmMonitoringActive = false

    local carsFolder = workspace:FindFirstChild("Cars")
    if carsFolder then
        for _, car in pairs(carsFolder:GetChildren()) do
            if car:GetAttribute("AutofarmActivated") then
                local parts = getSpecificParts(car)
                startAutofarm(parts, false)
                car:SetAttribute("AutofarmActivated", false)
            end
        end
    end
end

-- Zwrócenie funkcji do zarządzania
return {
    startSpinJumpMonitoring = startSpinJumpMonitoring,
    stopSpinJumpMonitoring = stopSpinJumpMonitoring,
    startAutofarmMonitoring = startAutofarmMonitoring,
    stopAutofarmMonitoring = stopAutofarmMonitoring
}

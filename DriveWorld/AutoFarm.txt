-- Funkcja do uruchomienia autofarm
local function startAutofarm(parts, player)
    local autofarmActive = true
    local maxHeight = 380
    local minHeight = 180
    local fallVelocity = -55
    local delayBetweenMoves = 0.05
    local function teleportPart(part)
        if not part:IsDescendantOf(workspace) then return end
        part.CFrame = CFrame.new(part.Position.X, maxHeight, part.Position.Z)
        while part.Position.Y > minHeight and autofarmActive do
            part.CFrame = CFrame.new(part.Position.X, part.Position.Y + fallVelocity * delayBetweenMoves, part.Position.Z)
            wait(delayBetweenMoves)
        end
        part.CFrame = CFrame.new(part.Position.X, maxHeight, part.Position.Z)
    end
    for _, part in pairs(parts) do
        coroutine.wrap(function()
            while autofarmActive do
                teleportPart(part)
                wait(delayBetweenMoves)
            end
        end)()
    end
    return function()
        autofarmActive = false
    end
end

-- Monitorowanie autofarm
local autofarmMonitoringActive = false
local stopAutofarmFunc = nil

local function startAutofarmMonitoring()
    if autofarmMonitoringActive then
        warn("Autofarm monitoring jest już aktywny!")
        return
    end

    autofarmMonitoringActive = true
    for _, car in pairs(workspace.Cars:GetChildren()) do
        if not car:GetAttribute("AutofarmActivated") then
            car:SetAttribute("AutofarmActivated", false)
        end
        local seats = car:FindFirstChild("Seats")
        if seats then
            local driverSeat = seats:FindFirstChild("Driver")
            if driverSeat then
                -- Sprawdzamy, czy gracz już siedzi w samochodzie
                local occupant = driverSeat.Occupant
                if occupant then
                    local character = occupant.Parent
                    if character then
                        local player = game.Players:GetPlayerFromCharacter(character)
                        if player and player == game.Players.LocalPlayer then
                            if not car:GetAttribute("AutofarmActivated") then
                                local parts = getSpecificParts(car)
                                stopAutofarmFunc = startAutofarm(parts, player)
                                car:SetAttribute("AutofarmActivated", true)
                            end
                        end
                    end
                end

                -- Monitorowanie zmian w siedzeniu kierowcy
                driverSeat:GetPropertyChangedSignal("Occupant"):Connect(function()
                    if not autofarmMonitoringActive then return end
                    local occupant = driverSeat.Occupant
                    if occupant then
                        local character = occupant.Parent
                        if character then
                            local player = game.Players:GetPlayerFromCharacter(character)
                            if player and player == game.Players.LocalPlayer then
                                if not car:GetAttribute("AutofarmActivated") then
                                    local parts = getSpecificParts(car)
                                    stopAutofarmFunc = startAutofarm(parts, player)
                                    car:SetAttribute("AutofarmActivated", true)
                                end
                            end
                        end
                    end
                end)
            end
        end
    end
end

local function stopAutofarmMonitoring()
    autofarmMonitoringActive = false
    if stopAutofarmFunc then
        stopAutofarmFunc()
    end
end

-- Funkcja do obracania i skakania części samochodu
local function spinAndJumpCarPart(object)
    if object:IsA("BasePart") then
        local bodyAngularVelocity = Instance.new("BodyAngularVelocity")
        bodyAngularVelocity.MaxTorque = Vector3.new(10000, 10000, 10000)
        bodyAngularVelocity.AngularVelocity = Vector3.new(0, 100, 0)
        bodyAngularVelocity.P = 5000
        bodyAngularVelocity.Parent = object

        local bodyVelocity = Instance.new("BodyVelocity")
        bodyVelocity.MaxForce = Vector3.new(100000, 100000, 100000)
        bodyVelocity.Velocity = Vector3.new(0, 200, 0)
        bodyVelocity.Parent = object

        task.spawn(function()
            local originalPosition = object.Position
            while true do
                object.CFrame = CFrame.new(originalPosition + Vector3.new(0, math.sin(tick() * 10) * 0.5, 0))
                task.wait(0.03)
            end
        end)
    else
        warn(object.Name .. " nie jest typu BasePart i został pominięty.")
    end
end

-- Monitorowanie SpinJump
local spinJumpMonitoringActive = false
local spinJumpConnections = {}

local function startSpinJumpMonitoring()
    print("Rozpoczynanie SpinJump Monitoring")

    if spinJumpMonitoringActive then
        warn("SpinJump monitoring już działa!")
        return
    end

    local carsFolder = workspace:FindFirstChild("Cars")
    if not carsFolder then
        warn("Folder 'Cars' nie istnieje w workspace!")
        return
    end

    spinJumpMonitoringActive = true

    for _, car in pairs(carsFolder:GetChildren()) do
        if not car:GetAttribute("SpinJumpActivated") then
            car:SetAttribute("SpinJumpActivated", false)
        end

        local seats = car:FindFirstChild("Seats")
        if not seats then
            warn("Samochód " .. car.Name .. " nie ma folderu 'Seats'.")
            return
        end
        local driverSeat = seats:FindFirstChild("Driver")
        if not driverSeat then
            warn("Samochód " .. car.Name .. " nie ma siedzenia 'Driver'.")
            return
        end

        -- Sprawdzanie, czy gracz już siedzi w samochodzie
        local occupant = driverSeat.Occupant
        if occupant then
            local character = occupant.Parent
            if character then
                local player = game.Players:GetPlayerFromCharacter(character)
                if player and player == game.Players.LocalPlayer then
                    if not car:GetAttribute("SpinJumpActivated") then
                        local parts = getSpecificParts(car)
                        for _, part in pairs(parts) do
                            spinAndJumpCarPart(part)
                        end
                        car:SetAttribute("SpinJumpActivated", true)
                    end
                end
            end
        end

        -- Monitorowanie zmian w siedzeniu kierowcy
        local connection = driverSeat:GetPropertyChangedSignal("Occupant"):Connect(function()
            if not spinJumpMonitoringActive then return end
            local occupant = driverSeat.Occupant
            if occupant then
                local character = occupant.Parent
                if character then
                    local player = game.Players:GetPlayerFromCharacter(character)
                    if player and player == game.Players.LocalPlayer then
                        if not car:GetAttribute("SpinJumpActivated") then
                            local parts = getSpecificParts(car)
                            for _, part in pairs(parts) do
                                spinAndJumpCarPart(part)
                            end
                            car:SetAttribute("SpinJumpActivated", true)
                        end
                    end
                end
            end
        end)

        table.insert(spinJumpConnections, connection)
    end

    print("Monitoring SpinJump aktywowany.")
end

local function stopSpinJumpMonitoring()
    spinJumpMonitoringActive = false
    for _, connection in pairs(spinJumpConnections) do
        connection:Disconnect()
    end
    spinJumpConnections = {}

    -- Zatrzymanie teleportowania
    for _, car in pairs(workspace.Cars:GetChildren()) do
        local parts = getSpecificParts(car)
        for _, part in pairs(parts) do
            -- Usuwamy BodyAngularVelocity i BodyVelocity
            for _, bodyPart in pairs(part:GetChildren()) do
                if bodyPart:IsA("BodyAngularVelocity") or bodyPart:IsA("BodyVelocity") then
                    bodyPart:Destroy()
                end
            end
        end
    end
end

-- Zwrócenie funkcji do zarządzania
return {
    startSpinJumpMonitoring = startSpinJumpMonitoring,
    stopSpinJumpMonitoring = stopSpinJumpMonitoring,
    startAutofarmMonitoring = startAutofarmMonitoring,
    stopAutofarmMonitoring = stopAutofarmMonitoring
}
